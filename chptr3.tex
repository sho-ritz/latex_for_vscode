%/**********************************************************************/
%		第4章：LEDマトリクスのフリッカ周波数差を用いたカメラベース可視光通信方式
%**********************************************************************/
\chapter{2つの異なる点滅周波数を用いた可視光通信方式}
\label{lbl_chptr5}


%======================================================================
% 4.1 提案方式の概要
%======================================================================
\section{提案方式の概要}
本節では、LEDマトリクスパネルを用いた可視光通信方式について説明する。
自分が提案する方式は、2つの異なる点滅周波数を用いてバイナリを表現してデータを送信する方式である。また、一枚のLEDマトリクスパネルを4つの領域に分割し、一回で送信できるデータ量の増加を目指した。これらのロジック等について説明する。


%======================================================================
% 4.2 送信側ハードウェア・ソフトウェア構成
%======================================================================
\section{可視光通信のロジック}

本節では、具体的な可視光通信のロジックについて説明する。具体的には点灯パターンの設計と分割領域における点灯パターンの設計について説明する。


\subsection{点灯パターンの設計}
今回のシステムでは、2つの点滅周波数を用いて、バイナリを表現し、それを受信部で復号する方式を採用した。

当初は、領域を4つに分割することを中心に検討していたため、全体を高い方の周波数で駆動させ、低い方の周波数領域は1/2になるように、2回に1回点灯させるようにする方式を検討していた。しかし、そのやり方では、duty比が高い方の周波数の時は100\%、低い方の周波数の時は50\%となる。これは、単位時間あたりで人間の目に入る光量が高周波領域の方が多くなってしまうため、人間の視覚的には激しいちらつきが発生してしまう。そのため、この方式は採用しなかった。（以下、この方式を「旧法」と呼ぶ）
それを考慮して新たに点灯パターンを設計した。具体的には、両方ともduty比が50\%となるようにする方式を採用した。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/flicker_pattern.png}
  \caption{提案方式におけるフリッカパターン}
  \label{fig:flicker_pattern}
\end{figure}

このパターンを用いることで、高い周波数の時は50\%、低い周波数の時も50\%となり、4スロットで見たときに輝度値が揃うため人間の視覚的に違和感が生まれにくくなる。

\subsection{バイナリ変換の方法}
実際に点灯パターンから受信側でバイナリとして変換する方法について説明する。
全体を4スロットで見て、点灯パターンが1010の場合は1、1100の場合は0としてバイナリを表現する。これを繰り返してバイナリを表現する。この方法を採用した理由は、バイナリのパターンによって見え方が変わらないようにするためである。例として、1スロットごとに見て、点灯していたら1,消灯していたら0としてバイナリを表現する方法を考える。この方法では、100....というバイナリパターンの場合、人間の目では一瞬点灯した後にその後ずっと消灯するため、基本的に真っ暗になってしまう。しかし、自分が考案した方法の場合、10000...というバイナリパターンだとしても4スロットで見たときに輝度値が揃うため人間の視覚的に違和感が生まれにくくなる。

当初は全体を120Hz(1スロット1/120s)で駆動させ、60Hzと30Hzで実験を行ったが、人間の目から見て若干のちらつきが生まれたため、この方式は採用しなかった。

人間の視覚は、臨界フリッカ融合周波数（critical flicker fusion）という周波数があり、その周波数以上はフリッカを感じなくなり、連続点灯に見えるという性質がある。条件によるが、およそ60Hzから100Hzと言われているため、120Hzは連続点灯に見える可能性が高い。そのため、高い周波数が120Hzになるように全体を480Hz(1スロット1/480s)で駆動させるようにした。

\subsection{分割領域における点灯パターンの設計}
ここでは、一枚のLEDマトリクスパネルを4つの領域に分割し、それぞれの領域で異なる点滅周波数を用いて同一のデータを並列に送信する方式を採用した。
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/split_matrix.png}
  \caption{4分割LEDマトリクスの走査制御}
  \label{fig:split_matrix}
\end{figure}

図3.2のような場合、受信側では1000というデータに変換することができる。このように、分割領域における点灯パターンを設計することで、一回で送信できるデータ量を増加させることができる。
この方法で実際に点灯した画像を図3.3に示す。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/splite_matrix_4.jpg}
  \caption{LEDマトリクスパネルを4つの領域に分割した画像}
  \label{fig:split_matrix_4}
\end{figure}

図3.3では縞が見えるが、この画像だけではビットは推定ができない。理由は、露光時間が1スロットである1/480sよりも長いため、正確にビットを推定することができないためである。しかし、画像からは縞模様ができていることが確認できる。スマホのカメラはローリングシャッター方式を採用しており、一回の撮影で上から下に光を取り込んでいるため、一回の露光でも上下で光を取り込む時刻が違う。そのため、今回は受信側のロジックまではしっかりと設計できていないため、細かな検討はできていないが、この縞模様のパターンからビットを推定することで、カメラのフレームレート以上のデータも受信できると考えられる。

\subsection{4分割以上の検証}
受信側の実装が間に合わず，分割数の増加によって受信側の実装負担がどの程度増えるかを見積もれなかった。そこで，4分割を前提に設計しつつ，8分割についても試験的に検証した。

8分割で点灯した場合、図3.5のようになる。
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/splited_8.jpg}
  \caption{LEDマトリクスパネルを8つの領域に分割した画像}
  \label{fig:splited_8}
\end{figure}

このように，送信側の技術的には分割数を増やす余地がある。受信側で安定して読み取れるのであれば，分割数をさらに増やすことで，より高速な通信が実現できると考えられる。
%======================================================================
% 4.4 フレーム構成とシンボル境界推定
%======================================================================
\section{フレーム構成とシンボル境界推定}
本研究では同期語は使用しておらず、フレーム境界の推定はFLAGの検出と輝度パターンの整合性に基づいて行う。

\subsection{送信フレームの構成}
送信するデータの全体設計は以下の図4.1の通りである。
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{assets/data_structure.png}
  \caption{送信データの全体設計}
  \label{fig:data_structure}
\end{figure}

図3.4において、FLAGはデータの開始位置と終了位置を示すものであり、Payloadは実際に送信するデータの内容であり、CRCはビット誤り検出を行うものである。
この設計はHDLCのフレーム同期方式を参考にしている。


\subsection{FLAG検出とシンボル境界推定}
今回の方式では、FLAGを用いてデータの開始位置と終了位置を示す。今回、FLAGは 01111110 として設計したが、ペイロード内に 01111110 が含まれていた場合、そのビット列をFLAGとして誤検出してしまう問題がある。そこで本研究ではビットスタッフィングを適用し、ペイロード中に 1 が5回連続して現れた場合、その直後に 0 を挿入する。受信側では、1 が5回連続した後に現れる 0 を取り除く（デスタッフィング）ことで元のペイロードを復元する。この処理により、ペイロード中にFLAGと同一のビット列が出現しないことが保証され、FLAGの検出が可能となる。

シンボル境界推定について、本研究では 1100 を0、1010 を1に割り当て、1シンボルを4スロットで構成する。受信側でシンボル境界（位相）がずれた場合、4スロット窓で観測されるパターンは 1100 が 1001 や 0011 となるなど、送信時の並びと一致しなくなる。そのため、受信信号を1スロットずつシフトさせながら候補パターンとの整合を評価し、最も整合する位相をシンボル境界として採用する。特に 1010 は位相をずらしても 1010 または 0101 の交互パターンとなり、連続する 1 や 0 が生じにくい。この性質は位相推定における識別性を高める点で、本方式のシンボル設計の利点である。

ただし、カメラ撮像ノイズ等により、位相ずれではなく誤りによって 1001 のようなパターンが観測される可能性もある。そこで本研究では、ペイロード末尾にCRCを付与し、受信側で復号結果の整合性を検証する。具体的には、位相候補（0〜3スロットのシフト）ごとに復号を行い、CRC検証に合格する候補を正しい復号結果として採用する。これにより、シンボル境界推定の誤りや伝送中のビット誤りを高確率で検出でき、誤ったデータ列を上位層へ渡すことを防ぐ。


%======================================================================
% 4.5 受信アルゴリズム
%======================================================================
\section{受信アルゴリズム}

本節では，スマートフォンカメラで撮影されたフレーム列からbit列を復号するアルゴリズムについて述べる．

\subsection{フレーム列からの時系列データ生成}
受信側では，60fps程度で取得した動画をフレームに分解し，各フレームに対して4分割領域内の縞パターンを抽出する．本方式は4スロットで平均輝度が一致するように設計しているため，領域内の平均輝度からはbit差が得られない．そのため，ローリングシャッターによって生じる縞のパターンからビットの推定を行う．得られた縞プロファイルを時間方向に並べることで，領域ごとの時系列データを生成する．

\subsection{bitパターンとの類似度評価と位相推定}
送信側では1シンボルを4スロット（1スロット=1/480s）で構成しているため，受信側の60fpsでは1シンボルあたりの観測点が不足する可能性がある．そこで，縞パターンから得られた時系列データに対して，理論パターン1010および1100に対応する縞の並びと一致するかを評価する．

また，ローリングシャッターやフレームレートの揺らぎによる位相ずれに対応するため，開始位置を1フレームずつずらして複数の位相候補を評価する．各位相で得られたスコアが最大となるパターンを選択し，1010ならbit=1，1100ならbit=0として復号する．これにより，同一シンボル長でも撮影条件に依存しない復号が可能になる．

\subsection{復号フロー全体}
復号フローは，大きく「前処理」「FLAG検出」「payload復号」の3段階で構成される．まず前処理としてフレーム列から縞パターン時系列を生成し，正規化を行う．次に，FLAGパターンと一致する区間を探索してフレーム境界を決定する．このとき，位相をずらした複数候補を評価し，最も一致度の高い位置を採用する．

境界が確定した後は，payload領域に対してシンボルごとの類似度評価を行い，bit列を復号する．誤検出が発生した場合は，FLAG再検出に戻ることで再同期を行い，長いpayloadでも復号を継続できる構成とした．
